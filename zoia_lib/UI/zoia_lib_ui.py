
#
# MainWindow.ui is an xml file generated by the QTDesigner tool. That ui file is
# then run through the pyside2-uic.exe, which is included when you install
# pysdie2.:
#
# pyside2-uic.exe .\MainWindow.ui -o .\ui_main_window.py
#
# This file is then loaded as the base module for the UI window

import sys
import os
import psutil           # cross platform drive utils
from PySide2.QtWidgets import *
from PySide2.QtUiTools import QUiLoader
from PySide2 import QtCore
from PySide2 import QtGui

if __package__ is None or __package__ == '':
    # uses current directory visibility
    #import UI.ui_main_window as ui_mainwin
    from zoia_lib.UI import ui_main_window as ui_mainwin
else:
    # uses current package visibility
    from . import ui_main_window as ui_mainwin

class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        self.ui = ui_mainwin.Ui_main_window()
        self.ui.setupUi(self)
        self.basedirpath = os.path.expanduser('~') + '\\zoia_lib\\'
        self.sd_path = ""

        # file menu setup
        self.ui.action_connect_to_PatchStorage.triggered.connect(
            self.OnFileMenu_connect_to_PatchStorage)
        self.ui.action_update_files.triggered.connect(self.OnFileMenu_update)
        self.ui.action_upload_file.triggered.connect(self.OnFileMenu_upload)
        self.ui.action_quit.triggered.connect(self.OnFileMenu_quit)
        # SD Card menu set up. 
        # We build this menu on the fly when the user selects the menu bar
        self.ui.sdcard_menu.aboutToShow.connect(self.OnSDcard_Menu)
        # Test menu setup
        self.ui.action_print_current_SD_table.triggered.connect(
            self.OnPrintCurrentSDTable)
        self.ui.action_print_current_FS_table.triggered.connect(
            self.OnPrintCurrentFSTable)
        # Set up both of the Tabs for the fille systems
        self.setupSDTab()
        self.setupFSTab()

    # Set up all of the menu action objects
    def OnFileMenu_connect_to_PatchStorage(self):
        """ Stub for the connect to PatchStorge menu entry"""
        self.ui.statusbar.showMessage("Connecting to PatchStroage.")

    def OnFileMenu_update(self):
        """ Stub for the connect to update menu entry"""
        self.ui.statusbar.showMessage(
            "Updating local patches to Latest version.")

    def OnFileMenu_upload(self):
        """ Stub for the connect to upload menu entry"""
        self.ui.statusbar.showMessage(
            "Uploading selected pacthes to PatchStorage.")

    def OnFileMenu_quit(self):
        """ Stub for the connect to quit menu entry"""
        self.close()

    def OnSDcard_Menu(self):
        """ enumerates all of the mounted USB drives and populates the
        SD menu with all drives that are formatted FAT32. On Windows 10
        we can look specifically for 'FAT32' using fstype. On OSX psutil 
        returns 'msdos' for fstype.
        TODO: Test on linux :)
        """
        for disk in psutil.disk_partitions():
            if 'FAT32' in disk.fstype or 'msdos' in disk.fstype:# and "removable" in disk.opts:
                if len(self.ui.sdcard_menu.actions()) == 0:
                    act = self.ui.sdcard_menu.addAction(disk.mountpoint)
                    act.setCheckable(True)
                    act.triggered.connect(self.getSDPathFromMenu)
                else:
                    for action in self.ui.sdcard_menu.actions():
                        if disk.mountpoint in action.text():
                            pass
                        else:
                            act = self.ui.sdcard_menu.addAction(disk.mountpoint)
                            act.setCheckable(True)
                            act.triggered.connect(self.getSDPathFromMenu)
    
    def OnPrintCurrentSDTable(self):
        row = 0
        data = [self.sd_proxy_model.index(row,col).data
                for col in range(self.sd_proxy_model.columnCount())]
        print(data)

    def OnPrintCurrentFSTable(self):
        pass
    
    def setupFSTab(self):
        """ Set up the local file system tab
        """
        # local tab setup
        self.ui.local_filter_text.textChanged.connect(
            self.on_fs_filtertext_changed)
        # Stubbed in modelview. using the filesystem
        self.fs_model = QFileSystemModel()
        self.fs_model.setFilter(QtCore.QDir.NoDotAndDotDot
                                | QtCore.QDir.AllEntries
                                | QtCore.QDir.Dirs
                                | QtCore.QDir.Files)
        # FileSystemModel does all of its work on a seperate thread so we need
        # to generate a call back funstion
        self.fs_model.directoryLoaded.connect(self.on_fs_model_directoryLoaded)
        self.fs_index = self.fs_model.setRootPath(self.basedirpath)

        # filter the filename column based on the text field using
        # a proxy model
        self.fs_proxy_model = QtCore.QSortFilterProxyModel(
            recursiveFilteringEnabled=True,
            filterRole=QFileSystemModel.FileNameRole)
        self.fs_proxy_model.setSourceModel(self.fs_model)
        self.ui.local_tableview.setModel(self.fs_proxy_model)
        self.adjust_fs_root_index_tableview()

        # adjust the size of the table data
        self.ui.local_tableview.horizontalHeader().setSectionResizeMode(
            QHeaderView.Stretch)

    def on_fs_filtertext_changed(self, text):
        """ Function for the local filesystem filter tab."""
                # replace all of our  semicolons with and 'or' 
        substr = text.replace(";", "|")
        # build a regex finding any combination of substrings
        regex = "(?:{})".format(substr)        
        self.fs_proxy_model.setFilterRegExp(regex)
        self.adjust_fs_root_index_tableview()

    def adjust_fs_root_index_tableview(self):
        """Adjust the root and proxy index for the local tableview """
        root_index = self.fs_model.index(self.basedirpath)
        proxy_index = self.fs_proxy_model.mapFromSource(root_index)
        self.ui.local_tableview.setRootIndex(proxy_index)

    def on_fs_model_directoryLoaded(self):
        """ Triggered on the callback of the directory being loaded into the 
        model view. The directory load happens on a sperate thread so any 
        data we want to grab from that data has to happen here. 
        
        """
        statusmessage = "{}\t\t{} items".format(
            self.fs_model.rootPath(), self.fs_model.rowCount(self.fs_index))
        self.ui.statusbar.showMessage(statusmessage)

    def setupSDTab(self):
        """ Set up the SD card Tab
        """
        self.ui.sd_filter_text.textChanged.connect(
            self.on_sd_filtertext_changed)
        self.sd_model = QFileSystemModel()
        self.sd_model.setFilter(QtCore.QDir.NoDotAndDotDot
                                | QtCore.QDir.AllEntries
                                | QtCore.QDir.Dirs
                                | QtCore.QDir.Files)
        # FileSystemModel does all of its work on a seperate thread so we need
        # to generate a call back funstion
        self.sd_model.directoryLoaded.connect(self.on_sd_model_directoryLoaded)
        self.sd_index = self.sd_model.setRootPath(self.getSDPathFromMenu())
        # filter the filename column based on the text field using
        # a proxy model
        self.sd_proxy_model = QtCore.QSortFilterProxyModel(
            recursiveFilteringEnabled=True,
            filterRole=QFileSystemModel.FileNameRole)
        self.sd_proxy_model.setSourceModel(self.sd_model)
        self.ui.sd_tableview.setModel(self.sd_proxy_model)
        self.adjust_sd_root_index_tableview()
        # adjust the size of the table data
        self.ui.sd_tableview.horizontalHeader().setSectionResizeMode(
            QHeaderView.Stretch)

    def getSDPathFromMenu(self):
        """ Enumertates over the SD card menu finding the checked 
        drive letter and returning it. 
        
        The SD card menu should be populated with all of the mounted,
        Removable, FAT32 drives. It should also have the drive the user
        intends to read/write to checked.
        """
        for action in self.ui.sdcard_menu.actions():
            if action.isChecked():
                self.sd_path = action.text()
                self.adjust_sd_root_index_tableview()

    def on_sd_filtertext_changed(self, text):
        """ Function for the SD filesystem filter tab."""
        # replace all of our  semicolons with and 'or' 
        substr = text.replace(";", "|")
        # build a regex finding any combination of substrings
        regex = "(?:{})".format(substr)        
        self.sd_proxy_model.setFilterRegExp(regex)
        self.adjust_sd_root_index_tableview()

    def adjust_sd_root_index_tableview(self):
        """Adjust the root and proxy index for the local tableview """
        root_index = self.sd_model.index(self.sd_path)
        proxy_index = self.sd_proxy_model.mapFromSource(root_index)
        self.ui.sd_tableview.setRootIndex(proxy_index)

    def on_sd_model_directoryLoaded(self):
        """ Triggered on the callback of the directory being loaded into the 
        model view. The directory load happens on a sperate thread so any 
        data we want to grab from that data has to happen here. 
        
        """
        statusmessage = "{}\t\t{} items".format(
            self.sd_model.rootPath(), self.sd_model.rowCount(self.sd_index))
        self.ui.statusbar.showMessage(statusmessage)

if __name__ == "__main__":
    app = QApplication(sys.argv)

    window = MainWindow()
    window.show()

    sys.exit(app.exec_())
