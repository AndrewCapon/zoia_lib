#
# MainWindow.ui is an xml file generated by the QTDesigner tool. That ui file is
# then run through the pyside2-uic.exe, which is included when you install
# pysdie2.:
#
# pyside2-uic.exe .\MainWindow.ui -o .\ui_main_window.py
#
# This file is then loaded as the base module for the UI window

import os
import sys

import psutil  # cross platform drive utils
from PySide2 import QtCore
from PySide2.QtWidgets import *

if __package__ is None or __package__ == '':
    # uses current directory visibility
    # import UI.ui_main_window as ui_mainwin
    from zoia_lib.UI import ui_main_window as ui_mainwin
else:
    # uses current package visibility
    from . import ui_main_window as ui_mainwin


class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        self.ui = ui_mainwin.Ui_main_window()
        self.ui.setupUi(self)
        self.basedirpath = os.path.expanduser('~') + '\\zoia_lib\\'
        self.sd_path = ""

        # file menu setup
        self.ui.action_connect_to_PatchStorage.triggered.connect(
            self.on_filemenu_connect_to_patchstorage)
        self.ui.action_update_files.triggered.connect(self.on_filemenu_update)
        self.ui.action_upload_file.triggered.connect(self.on_filemenu_upload)
        self.ui.action_quit.triggered.connect(self.on_filemenu_quit)
        # SD Card menu set up. 
        # We build this menu on the fly when the user selects the menu bar
        self.ui.sdcard_menu.aboutToShow.connect(self.on_sdcard_menu)
        # Test menu setup
        self.ui.action_print_current_SD_table.triggered.connect(
            self.print_current_sd_table)
        self.ui.action_print_current_FS_table.triggered.connect(
            self.print_current_fs_table)
        # Set up both of the Tabs for the file systems
        self.setup_sd_tab()
        self.setup_fs_table()

    # Set up all of the menu action objects
    def on_filemenu_connect_to_patchstorage(self):
        """ Stub for the connect to PatchStorge menu entry"""
        self.ui.statusbar.showMessage("Connecting to PatchStroage.")

    def on_filemenu_update(self):
        """ Stub for the connect to update menu entry"""
        self.ui.statusbar.showMessage(
            "Updating local patches to latest version.")

    def on_filemenu_upload(self):
        """ Stub for the connect to upload menu entry"""
        self.ui.statusbar.showMessage(
            "Uploading selected patches to PatchStorage.")

    def on_filemenu_quit(self):
        """ Stub for the connect to quit menu entry"""
        self.close()

    def on_sdcard_menu(self):
        """ Enumerates all of the mounted USB drives and populates the
        SD menu with all drives that are formatted FAT32. On Windows 10
        we can look specifically for 'FAT32' using fstype. On OSX psutil 
        returns 'msdos' for fstype.

        OSX also refuses to draw an empty menu, so we have added a dummy
        action item a a label. We need to skip that when iterating over
        the action items

        TODO: Test on linux :)
        """
        for disk in psutil.disk_partitions():
            if 'FAT32' in disk.fstype or 'msdos' in disk.fstype:
                if len(self.ui.sdcard_menu.actions()) == 1:
                    act = self.ui.sdcard_menu.addAction(disk.mountpoint)
                    act.setCheckable(True)
                    act.setMenuRole(QAction.NoRole)
                    act.triggered.connect(self.get_sd_path_from_menu)
                else:
                    actionlist = self.ui.sdcard_menu.actions()
                    for index in range(1, len(actionlist)):
                        if disk.mountpoint in actionlist[index].text():
                            pass
                        else:
                            act = self.ui.sdcard_menu.addAction(disk.mountpoint)
                            act.setCheckable(True)
                            act.setMenuRole(QAction.NoRole)
                            act.triggered.connect(self.get_sd_path_from_menu)

    def print_current_sd_table(self):
        # root_index = self.sd_model.index(self.sd_path)
        # proxy_index = self.sd_proxy_model.mapFromSource(root_index)
        for row in range(self.sd_proxy_model.rowCount()):
            text = self.sd_proxy_model.index(row, 0).data()
            print(text)

    def print_current_fs_table(self):
        pass

    def setup_fs_table(self):
        """ Set up the local file system tab """
        # local tab setup
        self.ui.local_filter_text.textChanged.connect(
            self.on_fs_filtertext_changed)
        # Stubbed in modelview. using the filesystem
        self.fs_model = QFileSystemModel()
        self.fs_model.setFilter(QtCore.QDir.NoDotAndDotDot
                                | QtCore.QDir.AllEntries
                                | QtCore.QDir.Dirs
                                | QtCore.QDir.Files)
        # FileSystemModel does all of its work on a separate thread so we need
        # to generate a call back function
        self.fs_model.directoryLoaded.connect(self.on_fs_model_directory_loaded)
        self.fs_index = self.fs_model.setRootPath(self.basedirpath)

        # filter the filename column based on the text field using
        # a proxy model
        self.fs_proxy_model = QtCore.QSortFilterProxyModel(
            recursiveFilteringEnabled=True,
            filterRole=QFileSystemModel.FileNameRole)
        self.fs_proxy_model.setSourceModel(self.fs_model)
        self.ui.local_tableview.setModel(self.fs_proxy_model)
        self.adjust_fs_root_index_tableview()

        # adjust the size of the table data
        self.ui.local_tableview.horizontalHeader().setSectionResizeMode(
            QHeaderView.Stretch)

    def on_fs_filtertext_changed(self, text):
        """ Function for the local filesystem filter tab."""
        # replace all of our  semicolons with and 'or'
        substr = text.replace(";", "|")
        # build a regex finding any combination of substrings
        regex = "(?:{})".format(substr)
        self.fs_proxy_model.setFilterRegExp(regex)
        self.adjust_fs_root_index_tableview()

    def adjust_fs_root_index_tableview(self):
        """ Adjust the root and proxy index for the local tableview """
        root_index = self.fs_model.index(self.basedirpath)
        proxy_index = self.fs_proxy_model.mapFromSource(root_index)
        self.ui.local_tableview.setRootIndex(proxy_index)

    def on_fs_model_directory_loaded(self):
        """ Triggered on the callback of the directory being loaded into the 
        model view. The directory load happens on a separate thread so any
        data we want to grab from that data has to happen here.
        """
        statusmessage = "{}\t\t{} items".format(
            self.fs_model.rootPath(), self.fs_model.rowCount(self.fs_index))
        self.ui.statusbar.showMessage(statusmessage)

    def setup_sd_tab(self):
        """ Set up the SD card Tab """
        self.ui.sd_filter_text.textChanged.connect(
            self.on_sd_filtertext_changed)
        self.sd_model = QFileSystemModel()
        self.sd_model.setFilter(QtCore.QDir.NoDotAndDotDot
                                | QtCore.QDir.AllEntries
                                | QtCore.QDir.Dirs
                                | QtCore.QDir.Files)
        # FileSystemModel does all of its work on a seperate thread so we need
        # to generate a call back funstion
        self.sd_model.directoryLoaded.connect(self.on_sd_model_directory_loaded)
        self.sd_index = self.sd_model.setRootPath(self.get_sd_path_from_menu())
        # filter the filename column based on the text field using
        # a proxy model
        self.sd_proxy_model = QtCore.QSortFilterProxyModel(
            recursiveFilteringEnabled=True,
            filterRole=QFileSystemModel.FileNameRole)
        self.sd_proxy_model.setSourceModel(self.sd_model)
        self.ui.sd_tableview.setModel(self.sd_proxy_model)
        self.adjust_sd_root_index_tableview()
        # adjust the size of the table data
        self.ui.sd_tableview.horizontalHeader().setSectionResizeMode(
            QHeaderView.Stretch)

    def get_sd_path_from_menu(self):
        """ Enumerates over the SD card menu finding the checked
        drive letter and returning it. 
        
        The SD card menu should be populated with all of the mounted,
        Removable, FAT32 drives. It should also have the drive the user
        intends to read/write to checked.
        """
        for action in self.ui.sdcard_menu.actions():
            if action.isChecked():
                self.sd_path = action.text()
                self.adjust_sd_root_index_tableview()

    def on_sd_filtertext_changed(self, text):
        """ Function for the SD filesystem filter tab."""
        # replace all of our  semicolons with and 'or' 
        substr = text.replace(";", "|")
        # build a regex finding any combination of substrings
        regex = "(?:{})".format(substr)
        self.sd_proxy_model.setFilterRegExp(regex)
        self.adjust_sd_root_index_tableview()

    def adjust_sd_root_index_tableview(self):
        """ Adjust the root and proxy index for the local tableview """
        root_index = self.sd_model.index(self.sd_path)
        proxy_index = self.sd_proxy_model.mapFromSource(root_index)
        self.ui.sd_tableview.setRootIndex(proxy_index)

    def on_sd_model_directory_loaded(self):
        """ Triggered on the callback of the directory being loaded into the 
        model view. The directory load happens on a separate thread so any
        data we want to grab from that data has to happen here.
        """
        statusmessage = "{}\t\t{} items".format(
            self.sd_model.rootPath(), self.sd_model.rowCount(self.sd_index))
        self.ui.statusbar.showMessage(statusmessage)
